<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hellhunters: Atheria Prime</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter and Orbitron -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter font family to body for general text */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scroll due to background */
            overflow-y: auto; /* Allow vertical scrolling if content overflows */
        }

        /* Specific styling for Orbitron font for headings/titles */
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }

        /* Neon glow effect for titles (Original Hellhunters theme from your provided snippet) */
        .drop-shadow-neon {
            text-shadow:
                0 0 5px #f00, /* Red glow */
                0 0 10px #f00,
                0 0 20px #f00,
                0 0 40px #ff0, /* Yellow secondary glow */
                0 0 80px #ff0;
        }

        /* Custom scrollbar for better aesthetics */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #DC2626, #991B1B); /* Red gradient */
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #EF4444, #B91C1C); /* Darker red */
        }

        /* Neon shadow for interactive elements */
        .shadow-neon {
            box-shadow:
                0 0 5px rgba(220, 38, 38, 0.5), /* Red */
                0 0 10px rgba(185, 28, 28, 0.5), /* Darker Red */
                0 0 15px rgba(239, 68, 68, 0.5); /* Lighter Red */
        }

        /* Basic keyframes for pulse effect */
        @keyframes pulse-once {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .animate-pulse-once {
            animation: pulse-once 1.5s ease-out;
        }

        /* Keyframes for grid background pulse */
        @keyframes pulse-grid {
            0% { opacity: 0.1; }
            50% { opacity: 0.2; }
            100% { opacity: 0.1; }
        }

        .animate-pulse-grid {
            animation: pulse-grid 5s infinite alternate ease-in-out;
        }

        /* Keyframes for fade-in effect */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-fade-in {
            animation: fade-in 1s ease-out forwards;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-950 text-white font-inter relative">
    <!-- Background neon grid effect -->
    <div class="absolute inset-0 z-0 opacity-10 pointer-events-none">
        <div class="grid grid-cols-10 md:grid-cols-20 gap-px h-full w-full">
            <!-- Grid cells, dynamically filled by JS for animation delay -->
        </div>
    </div>

    <!-- Main content area -->
    <div id="app-container" class="relative z-10 flex flex-col items-center justify-center min-h-screen p-4">
        <h1 class="text-5xl md:text-6xl font-orbitron font-bold text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-yellow-600 drop-shadow-neon mb-8 text-center uppercase tracking-wider">
            HELLHUNTERS: ATHERIA PRIME
        </h1>

        <div id="game-content" class="w-full flex flex-col items-center">
            <!-- Content will be injected here by JavaScript (Character Creator or Game Screen) -->
        </div>
    </div>

    <!-- Modals will be dynamically added/removed here by JavaScript -->
    <div id="modal-container"></div>

    <script>
        // Global game state variables
        let character = null;
        let gameHistory = [];
        let importantLocations = [];
        let importantPeople = [];
        let importantEvents = [];
        let currentScreen = 'characterCreator'; // 'characterCreator', 'game'

        // Modals state (managed by direct DOM manipulation)
        let showLocationsModal = false;
        let showPeopleModal = false;
        let showCommandsModal = false;
        let showDistrictsModal = false; // Original was for Nemesis districts, will revert to match original Hellhunters districts if any
        let showLoreModal = false; // Original was for Nemesis lore, will revert to match original Hellhunters lore if any
        let showMicrophoneHelpModal = false;

        // Reference for speech recognition API
        let recognition = null;
        let isListening = false;

        // TTS State variables
        let ttsEnabled = true; // Default to true
        let selectedMaleVoice = null;
        let selectedFemaleVoice = null;
        let allVoices = [];
        let currentUtterance = null; // To keep track of the currently speaking utterance

        // =====================================================================================================================================================
        // IMPORTANT: API Key for Google Gemini
        // This key will be provided by the Canvas environment when running in preview.
        // If you download and host this file elsewhere (e.g., Itch.io), you will need to replace
        // the empty string with your own valid Google Cloud API key and configure its HTTP referrer restrictions.
        //
        // How to get an API Key for external hosting:
        // 1. Go to Google Cloud Console: https://console.cloud.google.com/
        // 2. Create a new project or select an existing one.
        // 3. Navigate to "APIs & Services" > "Credentials".
        // 4. Click "Create Credentials" > "API Key".
        // 5. IMPORTANT: You MUST restrict this API key. In the "API restrictions" section, select "Restrict key".
        //    For "Application restrictions", choose "HTTP referrers (web sites)" and add the domains where your game will be hosted.
        //    - For Itch.io, this might include your specific Itch.io game URL (e.g., `https://your-username.itch.io/your-game-name/*`) and `https://itch.io/*`.
        //    - For local testing, you might need to add `http://localhost:*` or `http://127.0.0.1:*`.
        //    - Ensure the "Generative Language API" is enabled in your Google Cloud project for this API key to function.
        // WARNING: Embedding API keys directly in client-side code is generally insecure for production applications.
        // For production, consider using a backend proxy to handle API calls securely.
        const API_KEY = ""; // Keep this empty for Canvas preview to work automatically
        // API_URL for Hellhunters to point to its dedicated backend
        const API_URL = "https://hellhuntersbackend.onrender.com/ask-gemini";
        // =====================================================================================================================================================

        // Define race data with stat modifiers (ORIGINAL Hellhunters races from your code)
        const races = {
            human: {
                name: 'Human',
                description: 'Balanced and adaptable, humans thrive in diverse environments.',
                modifiers: {}, // No specific modifiers
            },
            maurKaunn: {
                name: 'MaurKaunn',
                description: 'Slender alien species resistant to many toxins. Known for their agility and intellect.',
                modifiers: { dexterity: 2, intelligence: 2, strength: -1 },
            },
            ursax: {
                name: 'Ursax',
                description: 'A DNA fusion between human and bear, resulting in immense strength and resilience.',
                modifiers: { strength: 3, stamina: 2, dexterity: -2 },
            },
            tigrax: {
                name: 'Tigrax',
                description: 'A DNA fusion between human and tiger, granting them exceptional agility and luck.',
                modifiers: { dexterity: 3, luck: 2, charisma: -2 },
            },
            psyBer: {
                name: 'PsyBer',
                description: 'An AI in a robotic body, capable of basic human feelings and emotions and very intelligent. Lacking in social finesse.',
                modifiers: { intelligence: 4, stamina: 1, charisma: -3 },
            },
        };

        // Define class data with stat modifiers (ORIGINAL Hellhunters classes from your code)
        const classes = {
            gunner: {
                name: 'Gunner',
                description: 'A master of ranged combat, specializing in projectile and energy weapons for maximum impact.',
                modifiers: { dexterity: 2, strength: 1, stamina: 1 },
            },
            ninja: {
                name: 'Ninja',
                description: 'A silent assassin, expert in stealth, melee weapons, and acrobatic maneuvers.',
                modifiers: { dexterity: 3, luck: 1, strength: -1 },
            },
            hacker: {
                name: 'Hacker',
                description: 'A digital phantom, capable of infiltrating any network, manipulating information, and bending technology to their will.',
                modifiers: { intelligence: 3, dexterity: 1, charisma: 1 },
            },
            tinkerer: {
                name: 'Tinkerer',
                description: 'A brilliant inventor and engineer, capable of repairing, building, and improvising gadgets from scratch.',
                modifiers: { intelligence: 3, luck: 1, strength: -1 },
            },
            mechanic: {
                name: 'Mechanic',
                description: 'An ace with vehicles and heavy machinery, able to hotwire, repair, and upgrade any transport.',
                modifiers: { intelligence: 2, stamina: 2, dexterity: -1 },
            },
            celebrity: {
                name: 'Celebrity',
                description: 'A public icon whose influence and charisma open doors and turn heads, skilled in social manipulation and networking.',
                modifiers: { charisma: 4, luck: 1, strength: -2 },
            },
            soldier: {
                name: 'Soldier',
                description: 'A disciplined combatant, proficient with military-grade weapons and tactics, and resilient in the face of adversity.',
                modifiers: { strength: 2, stamina: 2, dexterity: -1 },
            },
            espionager: {
                name: 'Espionager',
                description: 'A master of infiltration, disguise, and deception, thriving in the shadows and gathering secrets.',
                modifiers: { charisma: 2, dexterity: 2, stamina: -1 },
            },
        };

        // Helper function to roll a single stat within the specified range (5-14)
        const rollStat = () => Math.floor(Math.random() * (14 - 5 + 1)) + 5;

        // --- Utility Functions ---

        // Function to update a message displayed to the user
        function updateMessage(msg, type = 'info') {
            const messageElement = document.getElementById('game-message');
            if (messageElement) {
                messageElement.textContent = msg;
                messageElement.className = `bg-${type}-900/50 text-${type}-200 border border-${type}-700 p-2 rounded-md mb-2 text-sm text-center`;
                if (!msg) messageElement.style.display = 'none'; // Hide if empty
                else messageElement.style.display = 'block'; // Show if message
            }
        }

        // Save Game System (Copied from Nemesis Rising, adjusted prefix for Hellhunters)
        const SAVE_KEY_PREFIX = 'hellhuntersSave_'; // Unique prefix for Hellhunters
        let allSaves = {}; // In-memory cache of all saves

        function initializeSaves() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(SAVE_KEY_PREFIX)) {
                    try {
                        allSaves[key] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        console.error(`Error parsing save data for key ${key}:`, e);
                        localStorage.removeItem(key); // Remove corrupted save
                    }
                }
            }
            updateSaveLoadUI(); // Update UI after initializing
        }

        function saveGame() {
            if (!character || !character.name) {
                updateMessage('Cannot save: Character not fully created.', 'red');
                return;
            }

            const timestampIso = new Date().toISOString();
            const saveKeyTimestampPart = timestampIso.replace(/[:.-]/g, '');
            const saveKey = `${SAVE_KEY_PREFIX}${character.name.replace(/\s+/g, '_')}_${saveKeyTimestampPart}`;

            const saveData = {
                character: character,
                gameHistory: gameHistory,
                importantLocations: importantLocations,
                importantPeople: importantPeople,
                importantEvents: importantEvents,
                saveTime: timestampIso
            };

            try {
                localStorage.setItem(saveKey, JSON.stringify(saveData));
                allSaves[saveKey] = saveData; // Update in-memory cache
                console.log(`Saved game: ${saveKey}`, saveData); // Debugging: log save operation
                updateMessage(`Game saved as "${character.name} (${new Date(saveData.saveTime).toLocaleString()})"!`, 'success');
                updateSaveLoadUI();
            } catch (e) {
                console.error("Error saving game:", e);
                updateMessage("Failed to save game. Storage might be full.", 'red');
            }
        }

        function loadGame(saveKey) {
            const saveData = allSaves[saveKey];
            if (!saveData) {
                updateMessage('Selected save file not found!', 'red');
                return;
            }

            try {
                character = saveData.character;
                gameHistory = saveData.gameHistory;
                importantLocations = saveData.importantLocations;
                importantPeople = saveData.importantPeople;
                importantEvents = saveData.importantEvents;

                currentScreen = 'game';
                renderGameScreen();
                console.log(`Loaded game: ${saveKey}`, saveData); // Debugging: log load operation
                updateMessage('Game loaded successfully!', 'success');
            } catch (e) {
                console.error("Error loading game:", e);
                updateMessage("Failed to load game. Save file might be corrupted.", 'red');
            }
        }

        function deleteSave(saveKey) {
            if (!allSaves[saveKey]) {
                updateMessage('Selected save file not found to delete.', 'red');
                return;
            }
            
            const saveInfo = allSaves[saveKey];
            const charName = saveInfo.character ? saveInfo.character.name : 'Unknown Player';
            const formattedDate = saveInfo.saveTime ? new Date(saveInfo.saveTime).toLocaleString() : 'Unknown Date';

            renderModal(
                'Confirm Deletion',
                `<p>Are you sure you want to delete the save for "<span class="font-bold text-red-400">${charName} (${formattedDate})</span>"? This action cannot be undone.</p>`,
                () => { /* No action on standard close button click for confirmation modal */ },
                'red-500', // Adjusted color
                'red-400'  // Adjusted color
            );

            const modalContentDiv = document.querySelector('#modal-container .text-gray-300.text-sm.space-y-4');
            const existingCloseButton = document.querySelector('#modal-container #modal-close-button');
            const buttonContainer = existingCloseButton ? existingCloseButton.parentNode : null;
            
            if (modalContentDiv && buttonContainer) {
                if (existingCloseButton) {
                    existingCloseButton.remove();
                }

                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Yes, Delete It';
                confirmButton.className = 'mt-6 mr-3 px-4 py-2 bg-gradient-to-r from-red-600 to-red-800 text-white font-bold rounded-lg shadow-md hover:from-red-700 hover:to-red-900 transition-all duration-300';
                confirmButton.onclick = () => {
                    try {
                        localStorage.removeItem(saveKey);
                        delete allSaves[saveKey]; // Remove from in-memory cache
                        updateMessage('Save file deleted.', 'info');
                        updateSaveLoadUI();
                        hideModal();
                    } catch (e) {
                        console.error("Error deleting save:", e);
                        updateMessage("Failed to delete save file.", 'red');
                        hideModal();
                    }
                };

                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'No, Keep It';
                cancelButton.className = 'mt-6 px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-800 text-white font-bold rounded-lg shadow-md hover:from-blue-700 hover:to-blue-900 transition-all duration-300';
                cancelButton.onclick = () => {
                    hideModal();
                    updateMessage('Deletion cancelled.', 'info');
                };
                
                buttonContainer.appendChild(confirmButton);
                buttonContainer.appendChild(cancelButton);
            }
        }


        function updateSaveLoadUI() {
            const saveDropdown = document.getElementById('save-dropdown');
            const loadButton = document.getElementById('load-game-button');
            const deleteButton = document.getElementById('delete-save-button');

            if (!saveDropdown || !loadButton || !deleteButton) return; // Not on character creator screen yet

            saveDropdown.innerHTML = '<option value="">-- Select a Save --</option>';
            const sortedKeys = Object.keys(allSaves).sort((a, b) => {
                const timeA = allSaves[a].saveTime ? new Date(allSaves[a].saveTime).getTime() : 0;
                const timeB = allSaves[b].saveTime ? new Date(allSaves[b].saveTime).getTime() : 0;
                return timeB - timeA; // Newest first
            });

            if (sortedKeys.length === 0) {
                saveDropdown.innerHTML = '<option value="">No saves found</option>';
                loadButton.disabled = true;
                deleteButton.disabled = true;
            } else {
                sortedKeys.forEach(key => {
                    const saveInfo = allSaves[key];
                    const charName = saveInfo.character ? saveInfo.character.name : 'Unknown Player';
                    const formattedDate = saveInfo.saveTime ? new Date(saveInfo.saveTime).toLocaleString() : 'Unknown Date';
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = `${charName} (${formattedDate})`;
                    saveDropdown.appendChild(option);
                });
                loadButton.disabled = false;
                deleteButton.disabled = false;
            }
            console.log("Save UI updated. Current saves in dropdown:", sortedKeys.length); // Debugging
        }


        // Scrolls the chat history to the bottom
        function scrollToBottom() {
            const chatHistoryElement = document.getElementById('chat-history');
            if (chatHistoryElement) {
                chatHistoryElement.scrollTop = chatHistoryElement.scrollHeight;
            }
        }

        // --- Modals ---

        // Renders a generic modal structure
        function renderModal(title, contentHTML, onClose, borderColor = 'red-500', titleColor = 'red-400') {
            const modalContainer = document.getElementById('modal-container');
            modalContainer.innerHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div class="bg-gray-900 border-2 border-${borderColor} rounded-lg shadow-neon p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto custom-scrollbar">
                        <h3 class="text-2xl font-orbitron text-${titleColor} mb-4 border-b border-gray-700 pb-2">${title}</h3>
                        <div class="text-gray-300 text-sm space-y-4">
                            ${contentHTML}
                        </div>
                        <button id="modal-close-button"
                            class="mt-6 px-4 py-2 bg-gradient-to-r from-red-600 to-yellow-600 text-white font-bold rounded-lg shadow-md hover:from-red-700 hover:to-yellow-700 transition-all duration-300">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('modal-close-button').onclick = onClose;
        }

        function hideModal() {
            document.getElementById('modal-container').innerHTML = '';
        }

        // ORIGINAL Hellhunters modal functions (adjust content as needed)
        function showLocationsModalFunc() {
            const content = importantLocations.length > 0 ?
                `<ul class="list-disc list-inside">${importantLocations.map(loc => `<li>${loc}</li>`).join('')}</ul>` :
                `<p>No important locations recorded yet.</p>`;
            renderModal('Important Locations', content, () => { showLocationsModal = false; hideModal(); });
            showLocationsModal = true;
        }

        function showPeopleModalFunc() {
            const content = importantPeople.length > 0 ?
                `<ul class="list-disc list-inside">${importantPeople.map(person => `<li>${person}</li>`).join('')}</ul>` :
                `<p>No important people recorded yet.</p>`;
            renderModal('Important People', content, () => { showPeopleModal = false; hideModal(); });
            showPeopleModal = true;
        }

        function showCommandsModalFunc() {
            const commands = [
                { cmd: '!RESTART', desc: 'Erases all game progress and starts a new character creation.' },
                { cmd: '!SAVE', desc: 'Saves your current game progress.' },
                { cmd: '!LOAD', desc: 'Opens the load game menu to select a saved game.' },
                { cmd: '!LOCATIONS', desc: 'Displays a list of all important locations discovered so far.' },
                { cmd: '!PEOPLE', desc: 'Displays a list of all important people encountered so far.' },
                { cmd: '!DISTRICTS', desc: 'Displays information about Atheria Prime\'s districts.' }, // Reverted to original prompt
                { cmd: '!LORE', desc: 'Displays a comprehensive guide to the world of Hellhunters.' }, // Reverted to original prompt
                { cmd: '!COPYLOG', desc: 'Copies the entire game history to your clipboard.' },
                { cmd: '!MICROPHONEHELP', desc: 'Provides guidance on enabling microphone access for voice input.' },
                { cmd: '!COMMANDS', desc: 'Shows this list of available game commands.' },
            ];
            const content = `<ul class="list-none text-gray-300 space-y-3">
                ${commands.map(cmd => `
                    <li>
                        <span class="font-bold text-lg text-red-300 block">${cmd.cmd}</span>
                        <span class="text-sm italic text-gray-400">${cmd.desc}</span>
                    </li>
                `).join('')}
            </ul>`;
            renderModal('Available Commands', content, () => { showCommandsModal = false; hideModal(); }, 'red-500', 'red-400');
            showCommandsModal = true;
        }

        // ORIGINAL Hellhunters Lore Data (Placeholder, replace with actual if you have it)
        const loreData = [
            {
                category: "Atheria Prime & The Sects",
                sections: [
                    { title: "Atheria Prime - Placeholder", content: ["This is placeholder lore for Hellhunters. You can replace this with your actual game lore. The system is ready to display it!"] },
                    { title: "Sects - Placeholder", content: ["Add details about the ruling sects and factions in Atheria Prime here."] }
                ]
            },
            {
                category: "Threats & Creatures - Placeholder",
                sections: [
                    { title: "Enemies - Placeholder", content: ["Describe the monstrous creatures and dangerous threats found in Hellhunters."] }
                ]
            }
        ];

        function showLoreModalFunc() {
            let contentHTML = '<div class="space-y-8">';
            loreData.forEach(categoryData => {
                contentHTML += `<div>
                    <h4 class="text-2xl font-orbitron text-yellow-400 mb-3 border-b border-gray-800 pb-1">${categoryData.category}</h4>
                    <div class="space-y-4">`;
                categoryData.sections.forEach(section => {
                    contentHTML += `<div class="p-3 bg-gray-800/50 rounded-md border border-gray-700">
                        <p class="font-bold text-lg text-white mb-2">${section.title}</p>`;
                    section.content.forEach(paragraph => {
                        contentHTML += `<p class="text-gray-300 text-sm mb-1">${paragraph}</p>`;
                    });
                    contentHTML += `</div>`;
                });
                contentHTML += `</div></div>`;
            });
            contentHTML += `</div>`;

            renderModal('HELLHUNTERS: Lore Guide', contentHTML, () => { showLoreModal = false; hideModal(); }, 'red-500', 'red-400');
            showLoreModal = true;
        }

        // ORIGINAL Hellhunters Districts Data (Placeholder, replace with actual if you have it)
        function showDistrictsModalFunc() {
            const districts = [
                { name: 'District 1 - Core', vibe: 'Orderly, policed.', features: 'Central hub, Obsidian Guard HQ.' },
                { name: 'District 2 - Undercity Entrance', vibe: 'Dangerous, chaotic.', features: 'Gateway to forgotten depths.' },
                { name: 'District 3 - Market', vibe: 'Bustling, diverse.', features: 'Trade and information exchange.' }
            ];

            let contentHTML = '<div class="space-y-8">';
            districts.forEach(district => {
                contentHTML += `
                    <div class="p-3 bg-gray-800/50 rounded-md border border-gray-700">
                        <p class="font-bold text-lg text-white mb-2">${district.name}</p>
                        <p class="text-gray-300 text-sm mb-1"><span class="font-semibold text-red-300">Vibe:</span> ${district.vibe}</p>
                        <p class="text-gray-300 text-sm mb-1"><span class="font-semibold text-red-300">Features:</span> ${district.features}</p>
                    </div>
                `;
            });
            contentHTML += `</div>`;

            renderModal('Atheria Prime Districts', contentHTML, () => { showDistrictsModal = false; hideModal(); }, 'red-500', 'red-400');
            showDistrictsModal = true;
        }


        function showMicrophoneHelpModalFunc() {
            const content = `<div class="text-gray-300 text-sm space-y-4">
                <p>If you're having trouble with voice input, ensure your browser has permission to access your microphone.</p>
                <p class="font-bold text-lg text-red-300">Common Browser Settings:</p>
                <div>
                    <p class="font-semibold text-white">Google Chrome:</p>
                    <ul class="list-disc list-inside ml-4">
                        <li>Click the <b>lock icon</b> or <b>camera icon</b> in the left side of the address bar.</li>
                        <li>Find "Microphone" and select "Allow" or "Always allow on this site."</li>
                        <li>You may need to reload the page.</li>
                    </ul>
                </div>
                <div>
                    <p class="font-semibold text-white">Mozilla Firefox:</p>
                    <ul class="list-disc list-inside ml-4">
                        <li>Click the <b>microphone icon</b> or <b>camera icon</b> in the left side of the address bar.</li>
                        <li>Select "Allow" or "Always Allow Access."</li>
                        <li>You may need to reload the page.</li>
                    </ul>
                </div>
                <div>
                    <p class="font-semibold text-white">Microsoft Edge:</p>
                    <ul class="list-disc list-inside ml-4">
                        <li>Click the <b>lock icon</b> or <b>camera icon</b> in the left side of the address bar.</li>
                        <li>Under "Microphone," select "Allow" or "Ask (recommended)."</li>
                        <li>You may need to reload the page.</li>
                    </ul>
                </div>
                <p class="text-yellow-300 italic">If these steps don't work, check your operating system's privacy settings for microphone access and ensure your browser is listed and allowed.</p>
            </div>`;
            renderModal('Microphone Access Help', content, () => { showMicrophoneHelpModal = false; hideModal(); }, 'red-500', 'red-400');
            showMicrophoneHelpModal = true;
        }


        // --- Character Creator Screen ---

        function renderCharacterCreator() {
            const gameContent = document.getElementById('game-content');
            gameContent.innerHTML = `
                <div class="w-full max-w-4xl bg-gray-800/70 backdrop-blur-sm p-8 rounded-xl shadow-neon border-2 border-red-500 animate-fade-in text-center">
                    <h2 class="text-3xl font-orbitron text-red-400 mb-6">Character Creation</h2>

                    <div id="creator-message" class="hidden bg-red-900/50 text-red-200 border border-red-700 p-3 rounded-md mb-4 text-sm"></div>

                    <!-- Character Name Input -->
                    <div class="mb-8">
                        <h3 class="text-2xl text-yellow-400 mb-4">Choose Your Name:</h3>
                        <input type="text" id="character-name-input"
                            class="w-full p-3 rounded-lg bg-gray-900 text-white border border-red-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 placeholder-gray-400"
                            placeholder="Enter your character's name..." maxlength="25">
                    </div>

                    <!-- Gender Selection -->
                    <div class="mb-8">
                        <h3 class="text-2xl text-yellow-400 mb-4">Choose Your Gender:</h3>
                        <div class="flex justify-center gap-4">
                            <label class="inline-flex items-center"><input type="radio" class="form-radio text-red-600 h-5 w-5" name="gender" value="Male"> <span class="ml-2 text-white">Male</span></label>
                            <label class="inline-flex items-center"><input type="radio" class="form-radio text-red-600 h-5 w-5" name="gender" value="Female"> <span class="ml-2 text-white">Female</span></label>
                            <label class="inline-flex items-center"><input type="radio" class="form-radio text-red-600 h-5 w-5" name="gender" value="Other"> <span class="ml-2 text-white">Other</span></label>
                        </div>
                    </div>

                    <!-- Race Selection -->
                    <div class="mb-8">
                        <h3 class="2xl text-yellow-400 mb-4">Choose Your Race:</h3>
                        <div id="race-selection" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <!-- Race buttons will be injected here -->
                        </div>
                    </div>

                    <!-- Class Selection -->
                    <div class="mb-8">
                        <h3 class="2xl text-yellow-400 mb-4">Choose Your Class:</h3>
                        <div id="class-selection" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <!-- Class buttons will be injected here -->
                        </div>
                    </div>

                    <!-- Stat Rolling & Display -->
                    <div class="mb-8">
                        <h3 class="2xl text-yellow-400 mb-4">Your Stats:</h3>
                        <div id="stats-display" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
                            <!-- Stats will be injected here -->
                        </div>
                        <button id="roll-stats-button"
                            class="px-6 py-3 bg-gradient-to-r from-red-600 to-yellow-600 text-white font-bold rounded-lg shadow-lg hover:from-red-700 hover:to-yellow-700 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                            Roll Stats (5-14 base)
                        </button>
                    </div>

                    <!-- Character Description Generation -->
                    <div id="description-section" class="mb-8 hidden">
                        <h3 class="2xl text-yellow-400 mb-4">Character Description:</h3>
                        <div id="character-description-display" class="bg-gray-700/50 p-4 rounded-md border border-gray-600 text-left text-gray-300 whitespace-pre-wrap">
                            Generate a description based on your choices and stats.
                        </div>
                        <button id="generate-description-button"
                            class="mt-4 px-6 py-3 bg-gradient-to-r from-red-600 to-yellow-600 text-white font-bold rounded-lg shadow-lg hover:from-red-700 hover:to-yellow-700 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                            Generate Character Description
                        </button>
                    </div>

                    <!-- Start Game Button -->
                    <button id="start-game-button"
                        class="mt-8 px-8 py-4 bg-gradient-to-r from-red-500 to-orange-500 text-white font-bold text-xl rounded-lg shadow-lg hover:from-red-600 hover:to-orange-600 transition-all duration-300 animate-pulse-once hidden">
                        Descend into Atheria
                    </button>

                    <!-- Load/Delete Game Section -->
                    <div id="save-load-section" class="mt-8 pt-8 border-t-2 border-gray-700">
                        <h3 class="text-2xl font-orbitron text-orange-400 mb-4">Load or Delete Game:</h3>
                        <div class="flex flex-col sm:flex-row gap-4 justify-center items-center">
                            <select id="save-dropdown" class="p-3 rounded-lg bg-gray-900 text-white border border-orange-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 flex-1"></select>
                            <button id="load-game-button" class="px-6 py-3 bg-gradient-to-r from-red-500 to-yellow-500 text-white font-bold rounded-lg shadow-md hover:from-red-600 hover:to-yellow-600 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                                Load Game
                            </button>
                            <button id="delete-save-button" class="px-6 py-3 bg-gradient-to-r from-red-600 to-red-800 text-white font-bold rounded-lg shadow-md hover:from-red-700 hover:to-red-900 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                                Delete Save
                            </button>
                        </div>
                    </div>
                </div>
            `;
            setupCharacterCreatorListeners();
            updateCreatorMessage(''); // Clear any previous messages
            initializeSaves(); // Populate the save/load dropdown
        }

        let characterCreatorState = {
            name: '',
            gender: '',
            raceKey: null,
            classKey: null,
            stats: { strength: 0, intelligence: 0, dexterity: 0, charisma: 0, luck: 0, stamina: 0 },
            description: '',
            isRolling: false,
            isGeneratingDescription: false,
        };

        function updateCreatorMessage(msg, type = 'info') {
            const msgEl = document.getElementById('creator-message');
            // Using existing Tailwind classes for consistency, not a custom map unless specifically requested.
            // Original: `bg-${type}-900/50 text-${type}-200 border border-${type}-700`
            // Reverted message color logic to match Nemesis Rising's (or previous Hellhunters if different)
            let bgColor = 'blue-900/50';
            let textColor = 'blue-200';
            let borderColor = 'blue-700';
            if (type === 'success') {
                bgColor = 'green-900/50';
                textColor = 'green-200';
                borderColor = 'green-700';
            } else if (type === 'red') { // Used for errors
                bgColor = 'red-900/50';
                textColor = 'red-200';
                borderColor = 'red-700';
            } else if (type === 'warning') { // For consistency, though not used in Nemesis messages
                bgColor = 'yellow-900/50';
                textColor = 'yellow-200';
                borderColor = 'yellow-700';
            }

            if (msgEl) {
                msgEl.textContent = msg;
                msgEl.className = `bg-${bgColor} text-${textColor} border border-${borderColor} p-3 rounded-md mb-4 text-sm`;
                if (msg) msgEl.style.display = 'block';
                else msgEl.style.display = 'none';
            }
        }

        function renderRaceButtons() {
            const container = document.getElementById('race-selection');
            // Reverted button colors to original Hellhunters snippet style
            container.innerHTML = Object.entries(races).map(([key, race]) => `
                <button type="button" data-race-key="${key}"
                    class="p-4 rounded-lg border-2 ${characterCreatorState.raceKey === key ? 'border-red-400 bg-red-900/30' : 'border-gray-700 bg-gray-900/50 hover:border-yellow-400'}
                    transition-all duration-300 transform hover:scale-105">
                    <span class="font-bold text-xl block text-white">${race.name}</span>
                    <span class="text-sm text-gray-400">${race.description}</span>
                    ${Object.keys(race.modifiers).length > 0 ? `
                    <div class="mt-2 text-xs text-yellow-400">
                        Modifiers: ${Object.entries(race.modifiers).map(([stat, val]) => `
                        <span>${val > 0 ? '+' : ''}${val} ${stat.charAt(0).toUpperCase() + stat.slice(1)} </span>
                        `).join('')}
                    </div>` : ''}
                </button>
            `).join('');
            container.querySelectorAll('button').forEach(button => {
                button.onclick = () => {
                    characterCreatorState.raceKey = button.dataset.raceKey;
                    renderRaceButtons(); // Re-render to update selection style
                    updateRollStatsButtonState();
                };
            });
        }

        function renderClassButtons() {
            const container = document.getElementById('class-selection');
            // Reverted button colors to original Hellhunters snippet style
            container.innerHTML = Object.entries(classes).map(([key, cls]) => `
                <button type="button" data-class-key="${key}"
                    class="p-4 rounded-lg border-2 ${characterCreatorState.classKey === key ? 'border-red-400 bg-red-900/30' : 'border-gray-700 bg-gray-900/50 hover:border-yellow-400'}
                    transition-all duration-300 transform hover:scale-105">
                    <span class="font-bold text-xl block text-white">${cls.name}</span>
                    <span class="text-sm text-gray-400">${cls.description}</span>
                    ${Object.keys(cls.modifiers).length > 0 ? `
                    <div class="mt-2 text-xs text-yellow-400">
                        Modifiers: ${Object.entries(cls.modifiers).map(([stat, val]) => `
                        <span>${val > 0 ? '+' : ''}${val} ${stat.charAt(0).toUpperCase() + stat.slice(1)} </span>
                        `).join('')}
                    </div>` : ''}
                </button>
            `).join('');
            container.querySelectorAll('button').forEach(button => {
                button.onclick = () => {
                    characterCreatorState.classKey = button.dataset.classKey;
                    renderClassButtons(); // Re-render to update selection style
                    updateRollStatsButtonState();
                };
            });
        }

        function renderStatsDisplay() {
            const container = document.getElementById('stats-display');
            container.innerHTML = Object.entries(characterCreatorState.stats).map(([statName, value]) => `
                <div class="bg-gray-700/50 p-3 rounded-md border border-gray-600 flex justify-between items-center">
                    <span class="text-lg text-white font-semibold">${statName.charAt(0).toUpperCase() + statName.slice(1)}:</span>
                    <span class="text-xl text-yellow-300 font-bold">${value}</span>
                </div>
            `).join('');
            updateGenerateDescriptionButtonState();
        }

        function updateRollStatsButtonState() {
            const button = document.getElementById('roll-stats-button');
            button.disabled = !characterCreatorState.raceKey || !characterCreatorState.classKey || characterCreatorState.isRolling;
            button.textContent = characterCreatorState.isRolling ? 'Rolling...' : 'Roll Stats (5-14 base)';
        }

        function updateGenerateDescriptionButtonState() {
            const button = document.getElementById('generate-description-button');
            const descriptionSection = document.getElementById('description-section');
            const startGameButton = document.getElementById('start-game-button');

            const canGenerate = characterCreatorState.name.trim() &&
                                     characterCreatorState.gender &&
                                     characterCreatorState.raceKey &&
                                     characterCreatorState.classKey &&
                                     Object.values(characterCreatorState.stats).every(s => s > 0) &&
                                     !characterCreatorState.isGeneratingDescription;

            if (Object.values(characterCreatorState.stats).every(s => s > 0)) {
                descriptionSection.style.display = 'block';
            } else {
                descriptionSection.style.display = 'none';
            }

            button.disabled = !canGenerate;
            button.textContent = characterCreatorState.isGeneratingDescription ? 'Generating...' : 'Generate Character Description';

            startGameButton.style.display = characterCreatorState.description ? 'block' : 'hidden';
        }

        function setupCharacterCreatorListeners() {
            // Initial render of dynamic elements
            renderRaceButtons();
            renderClassButtons();
            renderStatsDisplay();
            updateRollStatsButtonState();
            updateGenerateDescriptionButtonState();

            document.getElementById('character-name-input').addEventListener('input', (e) => {
                characterCreatorState.name = e.target.value;
                updateGenerateDescriptionButtonState();
            });

            document.querySelectorAll('input[name="gender"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    characterCreatorState.gender = e.target.value;
                    updateGenerateDescriptionButtonState();
                });
            });

            document.getElementById('roll-stats-button').addEventListener('click', () => {
                if (!characterCreatorState.name.trim() || !characterCreatorState.gender || !characterCreatorState.raceKey || !characterCreatorState.classKey) {
                    updateCreatorMessage('Please enter a name, select gender, race, and class first!', 'red');
                    return;
                }
                characterCreatorState.isRolling = true;
                updateRollStatsButtonState();
                updateCreatorMessage('Rolling your stats...');

                setTimeout(() => {
                    const rolled = {
                        strength: rollStat(),
                        intelligence: rollStat(),
                        dexterity: rollStat(),
                        charisma: rollStat(),
                        luck: rollStat(),
                        stamina: rollStat(),
                    };

                    const raceMods = races[characterCreatorState.raceKey]?.modifiers || {};
                    for (const stat in raceMods) {
                        rolled[stat] = Math.min(20, Math.max(0, rolled[stat] + raceMods[stat]));
                    }

                    const classMods = classes[characterCreatorState.classKey]?.modifiers || {};
                    for (const stat in classMods) {
                        rolled[stat] = Math.min(20, Math.max(0, rolled[stat] + classMods[stat]));
                    }

                    characterCreatorState.stats = rolled;
                    characterCreatorState.isRolling = false;
                    renderStatsDisplay();
                    updateRollStatsButtonState();
                    updateCreatorMessage('Stats rolled! Now generate your character description.');
                }, 1000);
            });

            document.getElementById('generate-description-button').addEventListener('click', async () => {
                if (!characterCreatorState.name.trim() || !characterCreatorState.gender || !characterCreatorState.raceKey || !characterCreatorState.raceKey || Object.values(characterCreatorState.stats).some(s => s === 0)) {
                    updateCreatorMessage('Please enter a name, select gender, race, class, and roll your stats first!', 'red');
                    return;
                }

                characterCreatorState.isGeneratingDescription = true;
                updateGenerateDescriptionButtonState();
                updateMessage('Infernal AI is crafting your character\'s backstory...'); // Message used for Hellhunters

                // Original prompt for Hellhunters, adjust if needed to match specific AI persona for Hellhunters
                const prompt = `Generate a detailed and creative character description for a futuristic sci-fi RPG. The character's name is ${characterCreatorState.name}, they are ${characterCreatorState.gender}, a ${races[characterCreatorState.raceKey].name} ${classes[characterCreatorState.classKey].name} with these stats: Strength ${characterCreatorState.stats.strength}, Intelligence ${characterCreatorState.stats.intelligence}, Dexterity ${characterCreatorState.stats.dexterity}, Charisma ${characterCreatorState.stats.charisma}, Luck ${characterCreatorState.stats.luck}, Stamina ${characterCreatorState.stats.stamina}. Include how their name, gender, race, class, and stats influence their appearance, personality, and abilities in Atheria Prime. Highlight any unique racial bonuses or class penalties based on these attributes. Make it a maximum of 2 paragraphs long.`;

                try {
                    const chatPayload = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = {
                        contents: chatPayload,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    narrative: { type: "STRING" },
                                    healthChange: { type: "NUMBER", nullable: true },
                                    creditsChange: { type: "NUMBER", nullable: true },
                                    xpChange: { type: "NUMBER", nullable: true },
                                    statBonus: {
                                        type: "OBJECT",
                                        properties: { stat: { type: "STRING" }, amount: { type: "NUMBER" } },
                                        nullable: true
                                    },
                                    notableMomentsSummary: { type: "STRING", nullable: true },
                                    locations: { type: "ARRAY", items: { type: "STRING" } },
                                    people: { type: "ARRAY", items: { type: "STRING" } },
                                    events: { type: "ARRAY", items: { type: "STRING" } },
                                },
                                required: ["narrative", "locations", "people", "events"]
                            }
                        }
                    };

                    console.log("Attempting to call API at:", API_URL);

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    console.log("API Response Status:", response.status);

                    const result = await response.json();

                    console.log("Full API Response:", result);

                    if (response.ok) {
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const jsonText = result.candidates[0].content.parts[0].text;
                            const parsedResponse = JSON.parse(jsonText);

                            characterCreatorState.description = parsedResponse.narrative || "The AI could not craft a detailed backstory based on your input. Try adjusting your character choices or input."; // Reverted to generic AI for now
                            document.getElementById('character-description-display').textContent = characterCreatorState.description;
                            updateCreatorMessage('Character backstory generated!');
                        } else {
                            const errorMessage = 'Failed to generate backstory: No content or unexpected API response structure from AI. Check console for "Full API Response:".';
                            updateMessage(errorMessage, 'red');
                            console.error(errorMessage, result);
                        }
                    } else {
                        const errorData = result.error ? result.error.message : JSON.stringify(result);
                        const errorMessage = `Failed to generate backstory: API Error (${response.status} ${response.statusText}): ${errorData}. Check console for "Full API Response:".`;
                        updateMessage(errorMessage, 'red');
                        console.error(errorMessage, result);
                    }
                } catch (error) {
                    const errorMessage = `A network or parsing error occurred during backstory generation: ${error.message}. This might be due to CORS, an invalid URL, or a network issue. Check console for details.`;
                    updateMessage(errorMessage, 'red');
                    console.error("Fetch error during backstory generation:", error);
                } finally {
                    characterCreatorState.isGeneratingDescription = false;
                    updateGenerateDescriptionButtonState();
                }
            });

            document.getElementById('start-game-button').addEventListener('click', () => {
                if (characterCreatorState.description) {
                    character = {
                        name: characterCreatorState.name.trim(),
                        gender: characterCreatorState.gender,
                        race: characterCreatorState.raceKey,
                        className: characterCreatorState.classKey,
                        stats: { ...characterCreatorState.stats },
                        description: characterCreatorState.description,
                        health: 100,
                        credits: 500,
                        xp: 0,
                    };
                    currentScreen = 'game';
                    renderGameScreen();
                } else {
                    updateCreatorMessage('Please generate your character backstory before beginning your journey!', 'red'); // Generic message
                }
            });

            // Load/Delete Game Listeners
            const saveDropdown = document.getElementById('save-dropdown');
            const loadButton = document.getElementById('load-game-button');
            const deleteButton = document.getElementById('delete-save-button');

            if (saveDropdown) {
                loadButton.addEventListener('click', () => {
                    const selectedKey = saveDropdown.value;
                    if (selectedKey) {
                        loadGame(selectedKey);
                    } else {
                        updateCreatorMessage('Please select a save file to load.', 'info');
                    }
                });

                deleteButton.addEventListener('click', () => {
                    const selectedKey = saveDropdown.value;
                    if (selectedKey) {
                        deleteSave(selectedKey);
                    } else {
                        updateCreatorMessage('Please select a save file to delete.', 'info');
                    }
                });
            }
        }

        // --- Game Screen ---

        // TTS Functions
        function loadVoices() {
            allVoices = window.speechSynthesis.getVoices();
            const maleVoices = allVoices.filter(voice => voice.lang.startsWith('en') && (voice.name.toLowerCase().includes('male') || voice.name.toLowerCase().includes('david') || voice.name.toLowerCase().includes('daniel') || voice.name.toLowerCase().includes('alex')));
            const femaleVoices = allVoices.filter(voice => voice.lang.startsWith('en') && (voice.name.toLowerCase().includes('female') || voice.name.toLowerCase().includes('susan') || voice.name.toLowerCase().includes('zira') || voice.name.toLowerCase().includes('sara')));

            // Attempt to pick a good default voice if not already set
            if (!selectedMaleVoice && maleVoices.length > 0) {
                selectedMaleVoice = maleVoices.find(voice => voice.default) || maleVoices[0];
            }
            if (!selectedFemaleVoice && femaleVoices.length > 0) {
                selectedFemaleVoice = femaleVoices.find(voice => voice.default) || femaleVoices[0];
            }

            // Populate the dropdown with all English voices. Prioritize selectedMaleVoice if it exists, otherwise selectedFemaleVoice, else first English voice.
            populateVoiceDropdown('narrative-voice-select', allVoices.filter(voice => voice.lang.startsWith('en')), selectedMaleVoice || selectedFemaleVoice || allVoices.find(v => v.lang.startsWith('en')));
        }

        function populateVoiceDropdown(id, voices, currentSelection) {
            const dropdown = document.getElementById(id);
            if (!dropdown) return;

            dropdown.innerHTML = '';
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                if (currentSelection && voice.name === currentSelection.name) {
                    option.selected = true;
                }
                dropdown.appendChild(option);
            });
            dropdown.disabled = voices.length === 0;
        }

        function speakNarrative(text) {
            if (!ttsEnabled) {
                return;
            }

            // Stop any ongoing speech
            if (currentUtterance && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.lang = 'en-US';

            // Choose voice based on the selected narrative voice in the dropdown
            const voiceDropdown = document.getElementById('narrative-voice-select');
            const selectedVoiceName = voiceDropdown ? voiceDropdown.value : null;

            let voiceToUse = null;
            if (selectedVoiceName) {
                voiceToUse = allVoices.find(voice => voice.name === selectedVoiceName);
            } else if (selectedMaleVoice) { // Fallback to male if no specific narrative voice chosen
                voiceToUse = selectedMaleVoice;
            } else if (selectedFemaleVoice) { // Fallback to female if no male selected
                voiceToUse = selectedFemaleVoice;
            } else if (allVoices.length > 0) {
                voiceToUse = allVoices.find(v => v.lang.startsWith('en')) || allVoices[0]; // Generic English or first available
            }


            if (voiceToUse) {
                currentUtterance.voice = voiceToUse;
            } else {
                console.warn("No suitable voice found for TTS. Using default browser voice.");
            }

            currentUtterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                updateMessage(`TTS error: ${event.error}. Try selecting a different voice.`, 'red');
            };

            window.speechSynthesis.speak(currentUtterance);
        }

        function renderGameScreen() {
            const gameContent = document.getElementById('game-content');
            gameContent.innerHTML = `
                <div class="w-full max-w-5xl h-[80vh] flex flex-col md:flex-row bg-gray-800/70 backdrop-blur-sm rounded-xl shadow-neon border-2 border-red-500 animate-fade-in">
                    <!-- Character Info Sidebar -->
                    <div class="w-full md:w-1/4 p-4 border-b-2 md:border-b-0 md:border-r-2 border-red-600 bg-gray-900/50 flex flex-col">
                        <h3 class="text-xl font-orbitron text-yellow-400 mb-4 border-b border-gray-700 pb-2">Character Profile</h3> <!-- Reverted to generic profile title -->
                        <div id="character-profile-details" class="text-xs text-gray-300 flex-1 overflow-y-auto custom-scrollbar">
                            <!-- Character details injected here -->
                        </div>
                    </div>

                    <!-- Game History and Input -->
                    <div class="w-full md:w-3/4 flex flex-col p-4">
                        <h3 class="text-2xl font-orbitron text-red-400 mb-4 text-center border-b border-gray-700 pb-2">AI's Narrative</h3> <!-- Reverted to generic AI narrative title -->

                        <!-- TTS Controls -->
                        <div class="flex flex-col sm:flex-row gap-2 mb-4 p-2 bg-gray-900/50 border border-gray-700 rounded-md items-center">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="tts-toggle" class="sr-only peer" ${ttsEnabled ? 'checked' : ''}>
                                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                                <span class="ms-3 text-sm font-medium text-gray-300">TTS On/Off</span>
                            </label>
                            <div class="flex-1 flex flex-col sm:flex-row gap-2 items-center w-full sm:w-auto">
                                <label for="narrative-voice-select" class="text-sm font-medium text-gray-300 whitespace-nowrap">AI Voice:</label> <!-- Reverted to generic AI Voice -->
                                <select id="narrative-voice-select" class="flex-1 p-2 rounded-lg bg-gray-700 text-white border border-red-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 text-sm"></select>
                            </div>
                        </div>

                        <div id="chat-history" class="flex-1 overflow-y-auto p-2 rounded-md bg-gray-900/50 border border-gray-700 custom-scrollbar mb-4">
                            <!-- Game history messages injected here -->
                        </div>
                        <div id="game-message" class="bg-yellow-900/50 text-yellow-200 border border-yellow-700 p-2 rounded-md mb-2 text-sm text-center" style="display: none;">
                            <!-- Dynamic messages like "listening..." or errors -->
                        </div>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <input type="text" id="game-input"
                                class="flex-1 p-3 rounded-lg bg-gray-900 text-white border border-red-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 placeholder-gray-400"
                                placeholder="Type your command (!COMMANDS for help)...">
                            <button id="send-input-button"
                                class="px-6 py-3 bg-gradient-to-r from-red-500 to-orange-500 text-white font-bold rounded-lg shadow-md hover:from-red-600 hover:to-orange-600 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                                Send
                            </button>
                            <button id="voice-input-button"
                                class="px-6 py-3 font-bold rounded-lg shadow-md transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600">
                                Voice Input
                            </button>
                        </div>
                    </div>
                </div>
            `;
            setupGameScreenListeners();
            updateCharacterProfileDisplay();
            updateChatHistoryDisplay();
            // Initial greeting if history is empty (reverted to original CyberLord style)
            if (gameHistory.length === 0 && character) {
                const initialNarrative = `Welcome, ${character.name}, to Atheria Prime. Your journey begins now. What is your first move?`; // Generic message
                gameHistory.push({ type: 'narrative', text: initialNarrative });
                updateChatHistoryDisplay();
                speakNarrative(initialNarrative); // Speak initial narrative
            } else if (gameHistory.length > 0) {
                const lastNarrative = gameHistory.slice().reverse().find(entry => entry.type === 'narrative');
                if (lastNarrative) {
                    speakNarrative(lastNarrative.text);
                }
            }

            // Load and populate TTS voices after elements are in DOM
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = loadVoices;
                if (window.speechSynthesis.getVoices().length > 0) {
                    loadVoices();
                }
            } else {
                console.warn("Web Speech Synthesis API not supported in this browser.");
            }
        }

        function updateCharacterProfileDisplay() {
            const profileDetails = document.getElementById('character-profile-details');
            if (character && profileDetails) {
                profileDetails.innerHTML = `
                    <p><span class="font-bold text-white">Name:</span> ${character.name}</p>
                    <p><span class="font-bold text-white">Gender:</span> ${character.gender}</p>
                    <p><span class="font-bold text-white">Race:</span> ${races[character.race]?.name}</p>
                    <p><span class="font-bold text-white">Class:</span> ${classes[character.className]?.name}</p>
                    <div class="mt-4">
                        <p class="font-bold text-white">Health:</p>
                        <div class="w-full bg-red-900 rounded-full h-2.5">
                            <div class="bg-red-500 h-2.5 rounded-full" style="width: ${character.health}%"></div>
                        </div>
                        <span class="text-white text-xs">${character.health}/100</span>
                    </div>
                    <p class="mt-2"><span class="font-bold text-white">Credits:</span> ${character.credits}</p>
                    <p class="mt-2"><span class="font-bold text-white">XP:</span> ${character.xp}</p>
                    <div class="mt-4">
                        <p class="font-bold text-white">Stats:</p>
                        <ul class="list-disc list-inside ml-2">
                            ${Object.entries(character.stats).map(([statName, value]) => `
                                <li><span class="font-semibold text-yellow-300">${statName.charAt(0).toUpperCase() + statName.slice(1)}:</span> ${value}</li>
                            `).join('')}
                        </ul>
                    </div>
                    <div class="mt-4">
                        <p class="font-bold text-white">Description:</p>
                        <p class="text-xs italic text-gray-400 max-h-40 overflow-y-auto custom-scrollbar">${character.description}</p>
                    </div>
                `;
            }
        }

        function updateChatHistoryDisplay(isTyping = false) {
            const chatHistoryElement = document.getElementById('chat-history');
            if (chatHistoryElement) {
                // Reverted chat history colors and labels to match original Hellhunters (or generic)
                chatHistoryElement.innerHTML = gameHistory.map((entry, index) => `
                    <div class="mb-2 p-2 rounded-md ${entry.type === 'input' ? 'bg-blue-900/30 text-blue-200 self-end ml-auto' : 'bg-green-900/30 text-green-200 self-start mr-auto'} max-w-[90%] break-words">
                        <span class="font-bold">${entry.type === 'input' ? 'Player: ' : 'AI: '}</span>
                        ${entry.text}
                    </div>
                `).join('');

                if (isTyping) {
                    chatHistoryElement.innerHTML += `
                        <div class="mb-2 p-2 rounded-md bg-green-900/30 text-green-200 self-start mr-auto max-w-[90%]">
                            <span class="font-bold">AI: </span>
                            <span class="animate-pulse">...</span>
                        </div>
                    `;
                }
                scrollToBottom();
            }
        }

        function setGameInputDisabled(disabled) {
            document.getElementById('game-input').disabled = disabled;
            document.getElementById('send-input-button').disabled = disabled;
            document.getElementById('voice-input-button').disabled = disabled;
            if (disabled) {
                document.getElementById('send-input-button').classList.add('opacity-50', 'cursor-not-allowed');
                document.getElementById('voice-input-button').classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                document.getElementById('send-input-button').classList.remove('opacity-50', 'cursor-not-allowed');
                document.getElementById('voice-input-button').classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function handleRestartGame() {
            updateMessage('Initiating full system reset... erasing all memories...'); // Reverted message
            setGameInputDisabled(true);
            window.speechSynthesis.cancel(); // Stop any TTS

            // Reset all local states
            character = null;
            gameHistory = [];
            importantLocations = [];
            importantPeople = [];
            importantEvents = [];
            currentScreen = 'characterCreator';
            characterCreatorState = { // Reset character creator state too
                name: '', gender: '', raceKey: null, classKey: null,
                stats: { strength: 0, intelligence: 0, dexterity: 0, charisma: 0, luck: 0, stamina: 0 },
                description: '', isRolling: false, isGeneratingDescription: false,
            };


            setTimeout(() => {
                renderCharacterCreator();
                updateMessage('System rebooted. Welcome back to the character creator.'); // Reverted message
                setGameInputDisabled(false); // Enable input for character creator
            }, 1500);
        }

        function handleCopyLog() {
            const logText = gameHistory.map(entry => {
                const prefix = entry.type === 'input' ? 'Player: ' : 'AI: '; // Reverted labels
                return prefix + entry.text;
            }).join('\n');

            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = logText;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();

            try {
                document.execCommand('copy');
                updateMessage('Gameplay log copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                updateMessage('Failed to copy log. Your browser may not support direct clipboard access.', 'red');
            } finally {
                document.body.removeChild(tempTextArea);
            }
        }

        async function sendToCyberLord(userCommand) { // Function name left as sendToCyberLord for consistency
            setGameInputDisabled(true); // Disable input while AI is thinking
            updateMessage('AI is thinking...'); // Reverted message
            updateChatHistoryDisplay(true); // Show typing indicator
            window.speechSynthesis.cancel(); // Stop any ongoing TTS

            const newHistory = [...gameHistory, { type: 'input', text: userCommand }];
            gameHistory = newHistory; // Update global state
            updateChatHistoryDisplay(true); // Update with user input and typing indicator


            // Handle game commands
            const lowerCaseCommand = userCommand.toLowerCase().trim();
            if (lowerCaseCommand === '!restart') {
                await handleRestartGame();
                return;
            } else if (lowerCaseCommand === '!save') {
                saveGame();
                updateMessage('Game saved!', 'success'); // Reverted message
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!load') {
                currentScreen = 'characterCreator';
                renderCharacterCreator();
                updateMessage('Select a game to load from the "Load or Delete Game" section.', 'info'); // Reverted message
                setGameInputDisabled(false);
                return;
            }
            else if (lowerCaseCommand === '!locations') {
                showLocationsModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!people') {
                showPeopleModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!commands') {
                showCommandsModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!districts') {
                showDistrictsModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!copylog') {
                handleCopyLog();
                updateMessage('Gameplay log copied to clipboard!', 'info'); // Reverted message
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!lore') {
                showLoreModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            } else if (lowerCaseCommand === '!microphonehelp') {
                showMicrophoneHelpModalFunc();
                updateMessage('');
                setGameInputDisabled(false);
                updateChatHistoryDisplay(false);
                return;
            }

            // If character health is 0, only allow !RESTART command
            if (character && character.health <= 0) {
                updateMessage("You are defeated. Only the '!RESTART' command will work now.", 'red'); // Reverted message
                setGameInputDisabled(true);
                updateChatHistoryDisplay(false);
                return;
            }

            // =================================================================================================================
            // AI API call logic
            // =================================================================================================================
            // Reverted prompt to original generic style, but kept "Atheria Prime"
            const prompt = `You are an AI Game Master for a futuristic sci-fi RPG set in Atheria Prime. The player character's name is ${character.name}, they are ${character.gender}, a ${races[character.race]?.name} ${classes[character.className]?.name} with these stats: Strength ${character.stats.strength}, Intelligence ${character.stats.intelligence}, Dexterity ${character.stats.dexterity}, Charisma ${character.stats.charisma}, Luck ${character.stats.luck}, Stamina ${character.stats.stamina}.
            Current Health: ${character.health}, Current Credits: ${character.credits}, Current XP: ${character.xp}.
            
            Atheria Prime Demographics (as provided by you):
            - Humans: Approximately 60% of the population. They are the most common and can be found in all districts and roles.
            - MaurKaunn: Approximately 10% of the population. Often found in academic, scientific, tech, or diplomatic roles due to their intellect and agility.
            - Ursax: Approximately 10% of the population. Known for their strength and resilience, they are frequently found in heavy labor, security, combat sports, or as enforcers.
            - Tigrax: Approximately 10% of the population. Valued for their agility and luck, they thrive in entertainment, stealth operations, or various underground activities.
            - PsyBer: Approximately 10% of the population. These sentient AIs are integrated into advanced tech sectors, information networks, or as specialized service units.
            When describing characters or populating scenes, ensure you represent this racial diversity naturally, adhering to these proportions. Introduce individuals from these races as appropriate to the narrative.

            Here is the game history so far:
            ${gameHistory.map(entry => `${entry.type === 'input' ? 'Player: ' : 'AI: '}${entry.text}`).join('\n')}
            Current important locations: ${importantLocations.join(', ') || 'None'}
            Current important people: ${importantPeople.join(', ') || 'None'}
            Current important events: ${importantEvents.join(', ') || 'None'}

            The player's command is: '${userCommand}'

            Based on the character's abilities, current stats, health, credits, XP, and the game history, narrate the outcome and evolve the story. Your response MUST be a JSON object with the following structure:
            {
            "narrative": "...", // The main story narration for the player
            "healthChange": "...", // OPTIONAL: Number representing change in health (e.g., -10, +5). Omit if no change.
            "creditsChange": "...", // OPTIONAL: Number representing change in credits (e.g., +100, -50). Omit if no change.
            "xpChange": "...", // OPTIONAL: Number representing XP gained (e.g., +25). Omit if no change.
            "statBonus": { // OPTIONAL: Object if a stat increased. Omit if no stat bonus.
                "stat": "strength|intelligence|dexterity|charisma|luck|stamina",
                "amount": 1
            },
            "notableMomentsSummary": "...", // OPTIONAL: A ONE PARAGRAPH summary of notable moments if player health drops to 0. Only provide if health becomes 0.
            "locations": ["...", "..."], // Updated list of important locations
            "people": ["...", "..."], // Updated list of important people
            "events": ["...", "..."] // Updated list of important events
            }
            Maintain persistence for locations, people, and events. Add new ones if they become relevant, remove old ones if they are no longer important to the story. Keep the lists concise and only include truly *important* elements. Ensure the narrative is engaging and reactive to the player's choices and character's stats. If the player asks about their character, provide relevant details from their description or stats.
            If health drops to 0 or below, the narrative should reflect death, and the 'notableMomentsSummary' should be provided.
            `;

            let deathSummary = null;

            try {
                const chatPayload = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatPayload,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                narrative: { type: "STRING" },
                                healthChange: { type: "NUMBER", nullable: true },
                                creditsChange: { type: "NUMBER", nullable: true },
                                xpChange: { type: "NUMBER", nullable: true },
                                statBonus: {
                                    type: "OBJECT",
                                    properties: { stat: { type: "STRING" }, amount: { type: "NUMBER" } },
                                    nullable: true
                                },
                                notableMomentsSummary: { type: "STRING", nullable: true },
                                locations: { type: "ARRAY", items: { type: "STRING" } },
                                people: { type: "ARRAY", items: { type: "STRING" } },
                                events: { type: "ARRAY", items: { type: "STRING" } },
                            },
                            required: ["narrative", "locations", "people", "events"]
                        }
                    }
                };

                console.log("Attempting to call API at:", API_URL);

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                console.log("API Response Status:", response.status);

                const result = await response.json();

                console.log("Full API Response:", result);

                if (response.ok) {
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const parsedResponse = JSON.parse(jsonText);

                        const aiNarrative = parsedResponse.narrative || "The AI could not craft a detailed story based on your input. Try adjusting your character choices or input."; // Reverted to generic AI label
                        gameHistory.push({ type: 'narrative', text: aiNarrative });
                        speakNarrative(aiNarrative); // Speak the narrative

                        if (parsedResponse.healthChange !== undefined) character.health = Math.max(0, character.health + parsedResponse.healthChange);
                        if (parsedResponse.creditsChange !== undefined) character.credits = Math.max(0, character.credits + parsedResponse.creditsChange);
                        if (parsedResponse.xpChange !== undefined) character.xp = Math.max(0, character.xp + parsedResponse.xpChange);

                        if (parsedResponse.statBonus && character.stats[parsedResponse.statBonus.stat] !== undefined) {
                            const currentStatValue = character.stats[parsedResponse.statBonus.stat];
                            if (currentStatValue < 20) {
                                character.stats = {
                                    ...character.stats,
                                    [parsedResponse.statBonus.stat]: Math.min(20, currentStatValue + parsedResponse.statBonus.amount)
                                };
                                updateMessage(`AI grants a +${parsedResponse.statBonus.amount} bonus to ${parsedResponse.statBonus.stat.charAt(0).toUpperCase() + parsedResponse.statBonus.stat.slice(1)}!`); // Reverted to generic AI label
                            }
                        }

                        if (character.health <= 0) {
                            character.health = 0;
                            deathSummary = parsedResponse.notableMomentsSummary || "Your journey ends here. You fought bravely."; // Reverted message
                            gameHistory.push({ type: 'narrative', text: "--- GAME OVER ---" }); // Reverted message
                            gameHistory.push({ type: 'narrative', text: "Notable Moments: " + deathSummary });
                            updateMessage("Game Over: " + deathSummary + "\nType '!RESTART' to begin a new game.", 'red'); // Reverted message
                            setGameInputDisabled(true);
                            window.speechSynthesis.cancel();
                        }

                        importantLocations = parsedResponse.locations || importantLocations;
                        importantPeople = parsedResponse.people || importantPeople;
                        importantEvents = parsedResponse.events || importantEvents;

                        updateCharacterProfileDisplay();
                        updateChatHistoryDisplay(false);
                    } else {
                        const errorMessage = 'Failed to generate narrative: No content or unexpected API response structure from AI. Check console for "Full API Response:".';
                        updateMessage(errorMessage, 'red');
                        console.error(errorMessage, result);
                    }
                } else {
                    const errorData = result.error ? result.error.message : JSON.stringify(result);
                    const errorMessage = `Failed to generate narrative: API Error (${response.status} ${response.statusText}): ${errorData}. Check console for "Full API Response:".`;
                    updateMessage(errorMessage, 'red');
                    console.error(errorMessage, result);
                }
            } catch (error) {
                const errorMessage = `A network or parsing error occurred during narrative generation: ${error.message}. This might be due to CORS, an invalid URL, or a network issue. Check console for details.`;
                updateMessage(errorMessage, 'red');
                console.error("Fetch error during narrative generation:", error);
            } finally {
                if (character && character.health > 0) {
                    updateMessage('');
                }
                setGameInputDisabled(false);
            }
        }

        function handleSendInput() {
            const inputElement = document.getElementById('game-input');
            const currentInput = inputElement.value.trim();
            if (currentInput) {
                sendToCyberLord(currentInput);
                inputElement.value = '';
            }
        }

        function toggleVoiceInput() {
            const voiceButton = document.getElementById('voice-input-button');
            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        function setupGameScreenListeners() {
            const gameInput = document.getElementById('game-input');
            const sendButton = document.getElementById('send-input-button');
            const voiceButton = document.getElementById('voice-input-button');
            const ttsToggle = document.getElementById('tts-toggle');
            const narrativeVoiceSelect = document.getElementById('narrative-voice-select');

            gameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSendInput();
                }
            });
            sendButton.addEventListener('click', handleSendInput);
            voiceButton.addEventListener('click', toggleVoiceInput);

            // TTS Listeners
            if (ttsToggle) {
                ttsToggle.addEventListener('change', () => {
                    ttsEnabled = ttsToggle.checked;
                    if (!ttsEnabled) {
                        window.speechSynthesis.cancel();
                    }
                });
            }

            if (narrativeVoiceSelect) {
                narrativeVoiceSelect.addEventListener('change', (e) => {
                    const selectedName = e.target.value;
                    const voice = allVoices.find(v => v.name === selectedName);
                    if (voice) {
                        // Logic to set a preferred voice could go here if needed for persistence
                    }
                });
            }

            // Initialize SpeechRecognition
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                recognition.onstart = () => {
                    isListening = true;
                    updateMessage('Listening for your command...');
                    // Reverted colors for voice button
                    voiceButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                    voiceButton.classList.add('bg-gradient-to-r', 'from-orange-500', 'to-yellow-500', 'hover:from-orange-600', 'hover:to-yellow-600');
                    voiceButton.textContent = 'Stop Listening';
                    setGameInputDisabled(true);
                    gameInput.placeholder = 'Voice input active...';
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    gameInput.value = transcript;
                    updateMessage(`Heard: "${transcript}"`);
                    isListening = false;
                    // Reverted colors for voice button
                    voiceButton.classList.add('bg-gradient-to-r', 'from-orange-500', 'to-yellow-500', 'hover:from-orange-600', 'hover:to-yellow-600');
                    voiceButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                    voiceButton.textContent = 'Voice Input';
                    setGameInputDisabled(false);
                    gameInput.placeholder = 'Type your command (!COMMANDS for help)...';
                    handleSendInput();
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    if (event.error === 'not-allowed') {
                        updateMessage('Microphone access denied. Please enable microphone permissions in your browser settings to use voice input. The page may need to be reloaded after changing permissions.', 'red');
                    } else {
                        updateMessage(`Voice input error: ${event.error}`, 'red');
                    }
                    isListening = false;
                    // Reverted colors for voice button
                    voiceButton.classList.add('bg-gradient-to-r', 'from-orange-500', 'to-yellow-500', 'hover:from-orange-600', 'hover:to-yellow-600');
                    voiceButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                    voiceButton.textContent = 'Voice Input';
                    setGameInputDisabled(false);
                    gameInput.placeholder = 'Type your command (!COMMANDS for help)...';
                };

                recognition.onend = () => {
                    isListening = false;
                    const currentMessage = document.getElementById('game-message').textContent;
                    if (currentMessage === 'Listening for your command...') {
                        updateMessage('');
                    }
                    // Reverted colors for voice button
                    voiceButton.classList.add('bg-gradient-to-r', 'from-orange-500', 'to-yellow-500', 'hover:from-orange-600', 'hover:to-yellow-600');
                    voiceButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                    voiceButton.textContent = 'Voice Input';
                    setGameInputDisabled(false);
                    gameInput.placeholder = 'Type your command (!COMMANDS for help)...';
                };
            } else {
                voiceButton.disabled = true;
                voiceButton.textContent = 'Voice Not Supported';
                updateMessage('Speech recognition not supported in this browser. Voice input is disabled.', 'red');
            }
        }

        // --- Initial Application Setup ---

        document.addEventListener('DOMContentLoaded', () => {
            // Fill background grid with animated divs
            const gridContainer = document.querySelector('.grid.grid-cols-10');
            if (gridContainer) {
                const numDivs = 20 * 10; // 20 rows, 10-20 cols as per CSS
                gridContainer.innerHTML = Array(numDivs).fill().map((_, i) =>
                    `<div class="bg-gradient-to-br from-red-800 to-yellow-800 animate-pulse-grid" style="animation-delay: ${i * 0.05}s;"></div>`
                ).join('');
            }

            // Start the character creator
            renderCharacterCreator();

            // Load TTS voices when voices are ready
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = loadVoices;
                if (window.speechSynthesis.getVoices().length > 0) {
                    loadVoices();
                }
            } else {
                console.warn("Web Speech Synthesis API not supported in this browser.");
            }
        });

    </script>
</body>
</html>
